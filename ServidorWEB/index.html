<!DOCTYPE html>
<html>

<head>
    <title>Control ESP32</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        button {
            padding: 15px 25px;
            font-size: 16px;
            margin: 10px 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #545b62;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 14px;
        }

        .stat-item {
            text-align: center;
        }

        .hidden {
            display: none;
        }

        .connection-timeout {
            background-color: #e74c3c;
            color: white;
            border: 1px solid #c0392b;
        }
    </style>
</head>

<body>
    <h2>Control ESP32 - WebSocket Client</h2>

    <!-- Estado de conexi√≥n -->
    <div id="status" class="status disconnected">
        Desconectado
    </div>

    <!-- Estad√≠sticas -->
    <div class="stats">
        <div class="stat-item">
            <div>Reconexiones</div>
            <div id="reconnectCount">0</div>
        </div>
        <div class="stat-item">
            <div>√öltimo Ping</div>
            <div id="lastPing">-</div>
        </div>
        <div class="stat-item">
            <div>Uptime</div>
            <div id="uptime">0s</div>
        </div>
    </div>

    <!-- Controles -->
    <div>
        <button id="ledBtn" class="btn-primary" onclick="sendMessage('2')" disabled>
            Encender LED (Puerto 2)
        </button>
        <button class="btn-secondary" onclick="toggleConnection()">
            Reconectar
        </button>
        <button class="btn-secondary" onclick="toggleLog()">
            Mostrar/Ocultar Log
        </button>
    </div>

    <!-- Log de eventos -->
    <div id="logContainer" class="log hidden"></div>

    <script>
        class WebSocketManager {
            constructor(url) {
                this.url = url;
                this.socket = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 100; // M√°s intentos
                this.reconnectInterval = 1000; // 1 segundo inicial (m√°s r√°pido)
                this.heartbeatInterval = 5000; // 5 segundos (m√°s frecuente)
                this.heartbeatTimer = null;
                this.reconnectTimer = null;
                this.connectionStartTime = null;
                this.lastPingTime = null;
                this.connectionTimeout = null;
                this.isReconnecting = false;
                this.connectionTimeoutDuration = 5000; // 5 segundos timeout para conexi√≥n

                // UI elements
                this.statusEl = document.getElementById('status');
                this.ledBtn = document.getElementById('ledBtn');
                this.logEl = document.getElementById('logContainer');
                this.reconnectCountEl = document.getElementById('reconnectCount');
                this.lastPingEl = document.getElementById('lastPing');
                this.uptimeEl = document.getElementById('uptime');

                // Event handlers mejorados
                this.setupVisibilityHandlers();
                this.setupNetworkHandlers();

                // Iniciar conexi√≥n
                this.connect();

                // Actualizar UI cada segundo
                setInterval(() => this.updateUI(), 1000);

                // Verificar conexi√≥n cada 30 segundos
                setInterval(() => this.periodicConnectionCheck(), 30000);
            }

            setupVisibilityHandlers() {
                // Detectar cuando la p√°gina se oculta/muestra
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.log('üì± P√°gina visible - forzando reconexi√≥n...');
                        setTimeout(() => this.forceReconnect(), 500);
                    } else {
                        this.log('üì± P√°gina oculta');
                    }
                });

                // Detectar cuando la ventana pierde/gana foco
                window.addEventListener('focus', () => {
                    this.log('üîç Ventana en foco - forzando reconexi√≥n...');
                    setTimeout(() => this.forceReconnect(), 500);
                });

                window.addEventListener('blur', () => {
                    this.log('üò¥ Ventana sin foco');
                });

                // Detectar cuando se hace clic en la p√°gina (usuario activo)
                document.addEventListener('click', () => {
                    if (!this.isConnected()) {
                        this.log('üëÜ Usuario activo - verificando conexi√≥n...');
                        this.checkConnection();
                    }
                });
            }

            setupNetworkHandlers() {
                // Detectar cambios en la conectividad de red
                window.addEventListener('online', () => {
                    this.log('üåê Red disponible - reconectando...');
                    setTimeout(() => this.forceReconnect(), 1000);
                });

                window.addEventListener('offline', () => {
                    this.log('üì° Red perdida');
                    this.updateStatus('disconnected', 'Sin conexi√≥n a internet');
                });
            }

            isConnected() {
                return this.socket && this.socket.readyState === WebSocket.OPEN;
            }

            connect() {
                // Si ya hay una conexi√≥n activa o en progreso, no hacer nada
                if (this.socket && (this.socket.readyState === WebSocket.CONNECTING ||
                    this.socket.readyState === WebSocket.OPEN)) {
                    return;
                }

                // Limpiar socket anterior
                if (this.socket) {
                    this.socket.onopen = null;
                    this.socket.onclose = null;
                    this.socket.onerror = null;
                    this.socket.onmessage = null;
                }

                this.isReconnecting = true;
                this.log(`üîÑ Conectando a ${this.url}... (intento ${this.reconnectAttempts + 1})`);
                this.updateStatus('connecting', 'Conectando...');

                // Timeout para la conexi√≥n
                this.connectionTimeout = setTimeout(() => {
                    if (this.socket && this.socket.readyState === WebSocket.CONNECTING) {
                        this.log('‚è∞ Timeout de conexi√≥n - cancelando...');
                        this.socket.close();
                        this.updateStatus('connection-timeout', 'Timeout de conexi√≥n');
                        this.scheduleReconnect();
                    }
                }, this.connectionTimeoutDuration);

                try {
                    this.socket = new WebSocket(this.url);

                    this.socket.onopen = () => {
                        this.clearConnectionTimeout();
                        this.log('‚úÖ Conectado al WebSocket');
                        this.updateStatus('connected', 'Conectado');
                        this.connectionStartTime = Date.now();
                        this.reconnectAttempts = 0;
                        this.reconnectInterval = 1000; // Reset interval
                        this.isReconnecting = false;
                        this.startHeartbeat();
                    };

                    this.socket.onmessage = (event) => {
                        this.log(`üì® Mensaje recibido: ${event.data}`);
                        this.lastPingTime = Date.now();
                    };

                    this.socket.onclose = (event) => {
                        this.clearConnectionTimeout();
                        this.log(`‚ùå Conexi√≥n cerrada (c√≥digo: ${event.code}, raz√≥n: ${event.reason || 'Sin raz√≥n'})`);
                        this.updateStatus('disconnected', 'Desconectado');
                        this.stopHeartbeat();
                        this.isReconnecting = false;

                        // Reconectar inmediatamente si no fue manual
                        if (event.code !== 1000) { // 1000 = cierre normal
                            this.scheduleReconnect();
                        }
                    };

                    this.socket.onerror = (error) => {
                        this.clearConnectionTimeout();
                        this.log(`‚ùå Error en WebSocket: ${error}`);
                        this.updateStatus('disconnected', 'Error de conexi√≥n');
                        this.isReconnecting = false;
                    };

                } catch (error) {
                    this.clearConnectionTimeout();
                    this.log(`‚ùå Error creando WebSocket: ${error}`);
                    this.isReconnecting = false;
                    this.scheduleReconnect();
                }
            }

            clearConnectionTimeout() {
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
            }

            startHeartbeat() {
                this.stopHeartbeat();
                this.heartbeatTimer = setInterval(() => {
                    if (this.isConnected()) {
                        try {
                            this.socket.send('ping');
                            this.lastPingTime = Date.now();
                            this.log('üèì Heartbeat enviado');
                        } catch (error) {
                            this.log(`‚ùå Error enviando heartbeat: ${error}`);
                            this.checkConnection();
                        }
                    } else {
                        this.log('üíî Heartbeat fall√≥ - conexi√≥n perdida');
                        this.checkConnection();
                    }
                }, this.heartbeatInterval);
            }

            stopHeartbeat() {
                if (this.heartbeatTimer) {
                    clearInterval(this.heartbeatTimer);
                    this.heartbeatTimer = null;
                }
            }

            scheduleReconnect() {
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                }

                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    this.reconnectCountEl.textContent = this.reconnectAttempts;

                    // Backoff exponencial pero limitado
                    const delay = Math.min(this.reconnectInterval * Math.pow(1.2, this.reconnectAttempts), 10000);

                    this.log(`üîÑ Reintentando en ${(delay / 1000).toFixed(1)}s... (intento ${this.reconnectAttempts})`);

                    this.reconnectTimer = setTimeout(() => {
                        this.connect();
                    }, delay);
                } else {
                    this.log(`‚ùå M√°ximo de intentos alcanzado (${this.maxReconnectAttempts})`);
                    this.updateStatus('disconnected', 'Conexi√≥n fallida - Usar bot√≥n Reconectar');
                }
            }

            checkConnection() {
                if (!this.isConnected() && !this.isReconnecting) {
                    this.log('üîç Conexi√≥n perdida - reconectando inmediatamente...');
                    this.connect();
                } else if (this.isConnected()) {
                    // Verificar con ping
                    try {
                        this.socket.send('ping');
                        this.log('üîç Verificando conexi√≥n...');
                    } catch (error) {
                        this.log(`‚ùå Error verificando conexi√≥n: ${error}`);
                        this.connect();
                    }
                }
            }

            periodicConnectionCheck() {
                if (!this.isConnected() && !this.isReconnecting) {
                    this.log('‚è∞ Verificaci√≥n peri√≥dica - reconectando...');
                    this.connect();
                }
            }

            sendMessage(message) {
                if (this.isConnected()) {
                    try {
                        this.socket.send(message);
                        this.log(`üì§ Enviado: ${message}`);
                        return true;
                    } catch (error) {
                        this.log(`‚ùå Error enviando mensaje: ${error}`);
                        this.checkConnection();
                        return false;
                    }
                } else {
                    this.log('‚ùå No se puede enviar: conexi√≥n no disponible');
                    this.checkConnection();
                    return false;
                }
            }

            updateStatus(type, message) {
                this.statusEl.className = `status ${type}`;
                this.statusEl.textContent = message;
                this.ledBtn.disabled = (type !== 'connected');
            }

            updateUI() {
                if (this.connectionStartTime) {
                    const uptime = Math.floor((Date.now() - this.connectionStartTime) / 1000);
                    this.uptimeEl.textContent = `${uptime}s`;
                }

                if (this.lastPingTime) {
                    const timeSince = Math.floor((Date.now() - this.lastPingTime) / 1000);
                    this.lastPingEl.textContent = `${timeSince}s ago`;

                    // Si hace mucho que no hay ping, verificar conexi√≥n
                    if (timeSince > 30 && this.isConnected()) {
                        this.log('‚ö†Ô∏è Mucho tiempo sin respuesta - verificando...');
                        this.checkConnection();
                    }
                }
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                console.log(logEntry);

                this.logEl.innerHTML += logEntry + '<br>';
                this.logEl.scrollTop = this.logEl.scrollHeight;

                const lines = this.logEl.innerHTML.split('<br>');
                if (lines.length > 100) {
                    this.logEl.innerHTML = lines.slice(-100).join('<br>');
                }
            }

            forceReconnect() {
                this.log('üîÑ Reconexi√≥n forzada');
                this.clearConnectionTimeout();
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                }
                if (this.socket) {
                    this.socket.close();
                }
                this.reconnectAttempts = 0;
                this.isReconnecting = false;
                setTimeout(() => this.connect(), 100);
            }
        }

        // Inicializar WebSocket Manager
        const wsManager = new WebSocketManager("ws://192.168.1.159:8765");

        // Funciones globales para los botones
        function sendMessage(msg) {
            wsManager.sendMessage(msg);
        }

        function toggleConnection() {
            wsManager.forceReconnect();
        }

        function toggleLog() {
            const logContainer = document.getElementById('logContainer');
            logContainer.classList.toggle('hidden');
        }

        // Wake lock mejorado
        let wakeLock = null;
        if ('wakeLock' in navigator) {
            navigator.wakeLock.request('screen').then(lock => {
                wakeLock = lock;
                console.log('Wake lock activado');

                // Renovar wake lock cuando se pierde
                lock.addEventListener('release', () => {
                    console.log('Wake lock liberado, renovando...');
                    if (document.visibilityState === 'visible') {
                        navigator.wakeLock.request('screen').then(newLock => {
                            wakeLock = newLock;
                        }).catch(err => console.log('Error renovando wake lock:', err));
                    }
                });
            }).catch(err => {
                console.log('Wake lock no disponible:', err);
            });
        }
    </script>

</body>

</html>